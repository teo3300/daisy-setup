# vim:foldmethod=marker

# NOTE: Template configuration
#       This file is a template configuration for nginx running inside docker
#       When the container starts, the content of this file is copied in
#       /etc/nginx/nginx.conf,
#       Additionally, all environment variables are resolved
# To avoid this behavior from disrupting nginx's internal variables, prepend
#       them with $ instead of just $
# Be sure to pass variables to the container to make them available and to specify them
#       in envsubst, this is done to avoid breaking regex

events {
  worker_connections 1024;
}

# NOTE: If a 403 is returned, check that dns query is resolved by pihole, otherwise
#       the IP might be an external one

## HTTPS server template
#  # <Service name> {{{
#  server {
#    listen 443 ssl;
#    listen [::]:443 ssl;
#    http2 on;
#  
#    # Specify server name
#    server_name <service.domain>;
#  
#    # Points to certificate (must create them before rebooting nginx)
#    ssl_certificate /etc/letsencrypt/live/${SERVER_DOMAIN}/fullchain.pem;
#    ssl_certificate_key /etc/letsencrypt/live/${SERVER_DOMAIN}/privkey.pem;
#
#    # Only allow local access and VPN
#    allow 192.168.1.0/24;
#    allow 10.100.0.0/24;
#    deny all;
#
#    location / {
#      # Specify proxy pass
#      proxy_pass http://<service.host>:<service.port>;
#    }
#  }
#  # }}}

http {
  # Save logs for exposing to fail2ban but keep stdout logging
  access_log /dev/stdout;
  access_log /var/log/nginx/access.log;

  server_tokens off;
  charset utf-8;

# ## NOTE: Everything running under port 443 must be disabled on the first run to allow certbot to properly create the certificates
#   # Port 443 entrypoint {{{
   server {
     listen 443 default_server ssl;
     listen [::]:443 ssl;
     http2 on;
 
     server_name ${SERVER_DOMAIN};
 
     ssl_certificate /etc/letsencrypt/live/${SERVER_DOMAIN}/fullchain.pem;
     ssl_certificate_key /etc/letsencrypt/live/${SERVER_DOMAIN}/privkey.pem;
 
     allow 192.168.1.0/24;
     allow 10.100.0.0/24;
     deny all;
 
     location / {
       proxy_pass http://serben-rust:8123;
     }
  }
  # }}}

  # Bitwarden {{{
  server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
  
    server_name bitwarden.${SERVER_DOMAIN};
  
    ssl_certificate /etc/letsencrypt/live/bitwarden.${SERVER_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/bitwarden.${SERVER_DOMAIN}/privkey.pem;
      
    allow 192.168.1.0/24;
    allow 10.100.0.0/24;
    deny all;
  
    location / {
      proxy_pass http://bitwarden:80;
    }
  }
  # }}}

  # Serben {{{
  server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name serben.${SERVER_DOMAIN};

    ssl_certificate /etc/letsencrypt/live/serben.${SERVER_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/serben.${SERVER_DOMAIN}/privkey.pem;

    # allow 192.168.1.0/24;
    # allow 10.100.0.0/24;
    # deny all;

    location / {
      proxy_pass http://serben-rust:8123;
    }
  }
  # }}}

  # Gitea {{{
  server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name git.${SERVER_DOMAIN};

    ssl_certificate /etc/letsencrypt/live/git.${SERVER_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/git.${SERVER_DOMAIN}/privkey.pem;

    allow 192.168.1.0/24;
    allow 10.100.0.0/24;
    deny all;

    location / {
      proxy_pass http://gitea-frontend:3000;
    }
  }
  # }}}

#   # Jellyfin {{{
#   server {
#     listen 443 ssl;
#     listen [::]:443 ssl;
#     http2 on;
#   
#     server_name media.${SERVER_DOMAIN};
#   
#     ssl_certificate /etc/letsencrypt/live/media.${SERVER_DOMAIN}/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/media.${SERVER_DOMAIN}/privkey.pem;
#       
#     allow 192.168.1.0/24;
#     allow 10.100.0.0/24;
#     deny all;
#   
#     location / {
#       proxy_pass http://jellyfin:8096;
#     }
#   }
#   # }}}
# 
#   # Pihole {{{
#   server {
#     listen 443 ssl;
#     listen [::]:443 ssl;
#     http2 on;
#   
#     server_name pihole.${SERVER_DOMAIN};
#   
#     ssl_certificate /etc/letsencrypt/live/pihole.${SERVER_DOMAIN}/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/pihole.${SERVER_DOMAIN}/privkey.pem;
#       
#     allow 192.168.1.0/24;
#     allow 10.100.0.0/24;
#     deny all;
#   
#     location / {
#       proxy_pass http://pihole:80;
#     }
#   }
#   # }}}
# 
  # Nextcloud {{{
  server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
  
    server_name drive.${SERVER_DOMAIN};
  
    ssl_certificate /etc/letsencrypt/live/drive.${SERVER_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/drive.${SERVER_DOMAIN}/privkey.pem;
  
    allow 192.168.1.0/24;
    allow 10.100.0.0/24;
    deny all;

    location / {
      proxy_pass http://nextcloud-frontend:80;
    }

    # Redirect dav
    location /.well-known/carddav {
        return 301 $scheme://$host/remote.php/dav;
    }
    
    location /.well-known/caldav {
        return 301 $scheme://$host/remote.php/dav;
    }
    
    location ^~ /.well-known {
        return 301 $scheme://$host/index.php$uri;
    }
  }
  # }}}

  # Entrypoint for certbot {{{
  server {
    # Listen on port 80 to expose certbot
  
    listen 80;
    listen [::]:80;
  
    server_name ${SERVER_DOMAIN};
    server_tokens off;

    # Default: answer with a redirect to https
    location / {
      return 301 https://$host\$request_uri;
    }

    # If request goes to specific location, serve certbot challenge
    location /.well-known/acme-challenge/ {
      root /var/www/certbot;
    }
  
  }
 # }}}

}
